// @ts-nocheck
/* eslint-disable */
/* tslint:disable */
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: o7C61dL2AAD7uCRtgHRJ1p
// Component: kLfmrXKYIGkV

import * as React from "react";

import Head from "next/head";
import Link, { LinkProps } from "next/link";
import { useRouter } from "next/router";

import {
  Flex as Flex__,
  MultiChoiceArg,
  PlasmicDataSourceContextProvider as PlasmicDataSourceContextProvider__,
  PlasmicIcon as PlasmicIcon__,
  PlasmicImg as PlasmicImg__,
  PlasmicLink as PlasmicLink__,
  PlasmicPageGuard as PlasmicPageGuard__,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  Stack as Stack__,
  StrictProps,
  Trans as Trans__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  generateOnMutateForSpec,
  generateStateOnChangeProp,
  generateStateOnChangePropForCodeComponents,
  generateStateValueProp,
  get as $stateGet,
  hasVariant,
  initializeCodeComponentStates,
  initializePlasmicStates,
  makeFragment,
  omit,
  pick,
  renderPlasmicSlot,
  set as $stateSet,
  useCurrentUser,
  useDollarState,
  usePlasmicTranslator,
  useTrigger,
  wrapWithClassName
} from "@plasmicapp/react-web";
import {
  DataCtxReader as DataCtxReader__,
  useDataEnv,
  useGlobalActions
} from "@plasmicapp/react-web/lib/host";

import "@plasmicapp/react-web/lib/plasmic.css";

import projectcss from "./plasmic.module.css"; // plasmic-import: o7C61dL2AAD7uCRtgHRJ1p/projectcss
import sty from "./PlasmicProduktKarte.module.css"; // plasmic-import: kLfmrXKYIGkV/css

import _01AlignCenter8Icon from "./icons/PlasmicIcon___01AlignCenter8"; // plasmic-import: tMLqgywqlOwf/icon
import CompareIcon from "./icons/PlasmicIcon__Compare"; // plasmic-import: b70MsQ4r6aGN/icon
import _01AlignCenter3Icon from "./icons/PlasmicIcon___01AlignCenter3"; // plasmic-import: MBs4hU4IhJYq/icon
import _01AlignCenter9Icon from "./icons/PlasmicIcon___01AlignCenter9"; // plasmic-import: Y7Tw0JC8x9GW/icon

createPlasmicElementProxy;

export type PlasmicProduktKarte__VariantMembers = {
  highlight: "highlight";
};
export type PlasmicProduktKarte__VariantsArgs = {
  highlight?: SingleBooleanChoiceArg<"highlight">;
};
type VariantPropType = keyof PlasmicProduktKarte__VariantsArgs;
export const PlasmicProduktKarte__VariantProps = new Array<VariantPropType>(
  "highlight"
);

export type PlasmicProduktKarte__ArgsType = {
  produkt?: any;
};
type ArgPropType = keyof PlasmicProduktKarte__ArgsType;
export const PlasmicProduktKarte__ArgProps = new Array<ArgPropType>("produkt");

export type PlasmicProduktKarte__OverridesType = {
  root?: Flex__<"div">;
  img?: Flex__<typeof PlasmicImg__>;
  overlay?: Flex__<"div">;
  icon5?: Flex__<"div">;
  addToCart?: Flex__<"div">;
  icon6?: Flex__<"div">;
  icon7?: Flex__<"div">;
  heart2?: Flex__<"div">;
  icon4?: Flex__<"div">;
  eye?: Flex__<"div">;
  freeBox?: Flex__<"div">;
  tag?: Flex__<"div">;
  tagNew?: Flex__<"div">;
  _new?: Flex__<"div">;
  tagSale?: Flex__<"div">;
  color?: Flex__<"div">;
  color2?: Flex__<"div">;
  rating?: Flex__<"div">;
  price?: Flex__<"div">;
  _3500?: Flex__<"div">;
};

export interface DefaultProduktKarteProps {
  produkt?: any;
  highlight?: SingleBooleanChoiceArg<"highlight">;
  className?: string;
}

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicProduktKarte__RenderFunc(props: {
  variants: PlasmicProduktKarte__VariantsArgs;
  args: PlasmicProduktKarte__ArgsType;
  overrides: PlasmicProduktKarte__OverridesType;
  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const args = React.useMemo(
    () =>
      Object.assign(
        {},
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  const __nextRouter = useNextRouter();
  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;

  const stateSpecs: Parameters<typeof useDollarState>[0] = React.useMemo(
    () => [
      {
        path: "highlight",
        type: "private",
        variableType: "variant",
        initFunc: ({ $props, $state, $queries, $ctx }) => $props.highlight
      }
    ],
    [$props, $ctx, $refs]
  );
  const $state = useDollarState(stateSpecs, {
    $props,
    $ctx,
    $queries: {},
    $refs
  });

  return (
    <Stack__
      as={"div"}
      data-plasmic-name={"root"}
      data-plasmic-override={overrides.root}
      data-plasmic-root={true}
      data-plasmic-for-node={forNode}
      hasGap={true}
      className={classNames(
        projectcss.all,
        projectcss.root_reset,
        projectcss.plasmic_default_styles,
        projectcss.plasmic_mixins,
        projectcss.plasmic_tokens,
        sty.root,
        { [sty.roothighlight]: hasVariant($state, "highlight", "highlight") }
      )}
    >
      <PlasmicImg__
        data-plasmic-name={"img"}
        data-plasmic-override={overrides.img}
        alt={""}
        className={classNames(sty.img)}
        displayHeight={"338px"}
        displayMaxHeight={"none"}
        displayMaxWidth={"100%"}
        displayMinHeight={"0"}
        displayMinWidth={"0"}
        displayWidth={"auto"}
        loading={"lazy"}
        src={(() => {
          try {
            return $props.produkt.thumbnail;
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return undefined;
            }
            throw e;
          }
        })()}
      />

      <Stack__
        as={"div"}
        data-plasmic-name={"overlay"}
        data-plasmic-override={overrides.overlay}
        hasGap={true}
        className={classNames(projectcss.all, sty.overlay, {
          [sty.overlayhighlight]: hasVariant($state, "highlight", "highlight")
        })}
      >
        <Stack__
          as={"div"}
          data-plasmic-name={"icon5"}
          data-plasmic-override={overrides.icon5}
          hasGap={true}
          className={classNames(projectcss.all, sty.icon5)}
        >
          <div
            data-plasmic-name={"addToCart"}
            data-plasmic-override={overrides.addToCart}
            className={classNames(projectcss.all, sty.addToCart)}
          >
            <_01AlignCenter8Icon
              className={classNames(projectcss.all, sty.svg__j75R)}
              role={"img"}
            />
          </div>
        </Stack__>
        {false ? (
          <Stack__
            as={"div"}
            data-plasmic-name={"icon6"}
            data-plasmic-override={overrides.icon6}
            hasGap={true}
            className={classNames(projectcss.all, sty.icon6)}
          >
            <CompareIcon
              className={classNames(projectcss.all, sty.svg__gZ0B)}
              role={"img"}
            />
          </Stack__>
        ) : null}
        <Stack__
          as={"div"}
          data-plasmic-name={"icon7"}
          data-plasmic-override={overrides.icon7}
          hasGap={true}
          className={classNames(projectcss.all, sty.icon7)}
        >
          <div
            data-plasmic-name={"heart2"}
            data-plasmic-override={overrides.heart2}
            className={classNames(projectcss.all, sty.heart2)}
          >
            <_01AlignCenter3Icon
              className={classNames(projectcss.all, sty.svg___7Nx4T)}
              role={"img"}
            />
          </div>
        </Stack__>
        <Stack__
          as={"div"}
          data-plasmic-name={"icon4"}
          data-plasmic-override={overrides.icon4}
          hasGap={true}
          className={classNames(projectcss.all, sty.icon4)}
        >
          <div
            data-plasmic-name={"eye"}
            data-plasmic-override={overrides.eye}
            className={classNames(projectcss.all, sty.eye)}
          >
            <_01AlignCenter9Icon
              className={classNames(projectcss.all, sty.svg__mk3ML)}
              role={"img"}
            />
          </div>
        </Stack__>
      </Stack__>
      <div
        data-plasmic-name={"freeBox"}
        data-plasmic-override={overrides.freeBox}
        className={classNames(projectcss.all, sty.freeBox)}
      >
        <Stack__
          as={"div"}
          data-plasmic-name={"tag"}
          data-plasmic-override={overrides.tag}
          hasGap={true}
          className={classNames(projectcss.all, sty.tag)}
        >
          {(() => {
            try {
              return (
                new Date($props.produkt.node.created) >
                new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
              );
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return false;
              }
              throw e;
            }
          })() ? (
            <Stack__
              as={"div"}
              data-plasmic-name={"tagNew"}
              data-plasmic-override={overrides.tagNew}
              hasGap={true}
              className={classNames(projectcss.all, sty.tagNew)}
            >
              <div
                data-plasmic-name={"_new"}
                data-plasmic-override={overrides._new}
                className={classNames(
                  projectcss.all,
                  projectcss.__wab_text,
                  sty._new
                )}
              >
                {"Neu"}
              </div>
            </Stack__>
          ) : null}
          {(() => {
            try {
              return $props.produkt.pricing.onSale;
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return true;
              }
              throw e;
            }
          })() ? (
            <Stack__
              as={"div"}
              data-plasmic-name={"tagSale"}
              data-plasmic-override={overrides.tagSale}
              hasGap={true}
              className={classNames(projectcss.all, sty.tagSale)}
            >
              {(() => {
                try {
                  return true;
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return true;
                  }
                  throw e;
                }
              })() ? (
                <div
                  className={classNames(
                    projectcss.all,
                    projectcss.__wab_text,
                    sty.text___8Yy43
                  )}
                >
                  <React.Fragment>
                    {(() => {
                      try {
                        return $props.produkt.pricing.discount.gross + "%";
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return "10%";
                        }
                        throw e;
                      }
                    })()}
                  </React.Fragment>
                </div>
              ) : null}
            </Stack__>
          ) : null}
        </Stack__>
        <Stack__
          as={"div"}
          data-plasmic-name={"color"}
          data-plasmic-override={overrides.color}
          hasGap={true}
          className={classNames(projectcss.all, sty.color)}
        >
          {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
            (() => {
              try {
                return $props.produkt.node.variants.filter(v =>
                  v.attributes.find(a => a.attribute.slug === "farbe")
                );
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return [];
                }
                throw e;
              }
            })()
          ).map((__plasmic_item_0, __plasmic_idx_0) => {
            const currentVariant = __plasmic_item_0;
            const currentVariantIndex = __plasmic_idx_0;
            return (
              <div
                data-plasmic-name={"color2"}
                data-plasmic-override={overrides.color2}
                className={classNames(projectcss.all, sty.color2)}
                key={currentVariantIndex}
                style={(() => {
                  try {
                    return {
                      backgroundColor:
                        currentVariant.attributes[0].values[0].value
                    };
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return undefined;
                    }
                    throw e;
                  }
                })()}
              />
            );
          })}
        </Stack__>
      </div>
      <div
        className={classNames(
          projectcss.all,
          projectcss.__wab_text,
          sty.text__iZb3N
        )}
        style={{
          display: "-webkit-inline-box",
          WebkitBoxOrient: "vertical",
          WebkitLineClamp: 2,
          overflow: "hidden",
          textOverflow: "ellipsis",
          wordBreak: "break-word"
        }}
      >
        <React.Fragment>
          {(() => {
            try {
              return $props.produkt.productName;
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return "";
              }
              throw e;
            }
          })()}
        </React.Fragment>
      </div>
      {(() => {
        try {
          return true;
        } catch (e) {
          if (
            e instanceof TypeError ||
            e?.plasmicType === "PlasmicUndefinedDataError"
          ) {
            return true;
          }
          throw e;
        }
      })() ? (
        <Stack__
          as={"div"}
          data-plasmic-name={"rating"}
          data-plasmic-override={overrides.rating}
          hasGap={true}
          className={classNames(projectcss.all, sty.rating)}
        >
          <div
            className={classNames(
              projectcss.all,
              projectcss.__wab_text,
              sty.text__cBx5H
            )}
          >
            <React.Fragment>
              {(() => {
                try {
                  return (
                    ($props.produkt.metadata.Bewertungen ?? 0) + " Bewertungen"
                  );
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return "12 Bewertungen";
                  }
                  throw e;
                }
              })()}
            </React.Fragment>
          </div>
        </Stack__>
      ) : null}
      <Stack__
        as={"div"}
        data-plasmic-name={"price"}
        data-plasmic-override={overrides.price}
        hasGap={true}
        className={classNames(projectcss.all, sty.price)}
      >
        <div
          className={classNames(
            projectcss.all,
            projectcss.__wab_text,
            sty.text__kqorr
          )}
        >
          <React.Fragment>
            {(() => {
              try {
                return (() => {
                  const { start, stop } =
                    $props.produkt.productPricing.priceRange;
                  const startFormatted = start.gross
                    .toFixed(2)
                    .replace(".", ",");
                  if (stop.gross > start.gross) {
                    return `${startFormatted} € - ${stop.gross
                      .toFixed(2)
                      .replace(".", ",")} €`;
                  }
                  return `${startFormatted} €`;
                })();
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return "?,?? \u20ac";
                }
                throw e;
              }
            })()}
          </React.Fragment>
        </div>
        {(() => {
          try {
            return $props.produkt.pricing.onSale;
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return true;
            }
            throw e;
          }
        })() ? (
          <div
            data-plasmic-name={"_3500"}
            data-plasmic-override={overrides._3500}
            className={classNames(
              projectcss.all,
              projectcss.__wab_text,
              sty._3500
            )}
          >
            <React.Fragment>
              {(() => {
                try {
                  return (() => {
                    const { start, stop } =
                      $props.produkt.productPricing.priceRangeUndiscounted;
                    const startFormatted = start.gross
                      .toFixed(2)
                      .replace(".", ",");
                    if (stop.gross > start.gross) {
                      return `${startFormatted} € - ${stop.gross
                        .toFixed(2)
                        .replace(".", ",")} €`;
                    }
                    return `${startFormatted} €`;
                  })();
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return "?,?? \u20ac";
                  }
                  throw e;
                }
              })()}
            </React.Fragment>
          </div>
        ) : null}
      </Stack__>
    </Stack__>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  root: [
    "root",
    "img",
    "overlay",
    "icon5",
    "addToCart",
    "icon6",
    "icon7",
    "heart2",
    "icon4",
    "eye",
    "freeBox",
    "tag",
    "tagNew",
    "_new",
    "tagSale",
    "color",
    "color2",
    "rating",
    "price",
    "_3500"
  ],
  img: ["img"],
  overlay: [
    "overlay",
    "icon5",
    "addToCart",
    "icon6",
    "icon7",
    "heart2",
    "icon4",
    "eye"
  ],
  icon5: ["icon5", "addToCart"],
  addToCart: ["addToCart"],
  icon6: ["icon6"],
  icon7: ["icon7", "heart2"],
  heart2: ["heart2"],
  icon4: ["icon4", "eye"],
  eye: ["eye"],
  freeBox: ["freeBox", "tag", "tagNew", "_new", "tagSale", "color", "color2"],
  tag: ["tag", "tagNew", "_new", "tagSale"],
  tagNew: ["tagNew", "_new"],
  _new: ["_new"],
  tagSale: ["tagSale"],
  color: ["color", "color2"],
  color2: ["color2"],
  rating: ["rating"],
  price: ["price", "_3500"],
  _3500: ["_3500"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<T extends NodeNameType> =
  (typeof PlasmicDescendants)[T][number];
type NodeDefaultElementType = {
  root: "div";
  img: typeof PlasmicImg__;
  overlay: "div";
  icon5: "div";
  addToCart: "div";
  icon6: "div";
  icon7: "div";
  heart2: "div";
  icon4: "div";
  eye: "div";
  freeBox: "div";
  tag: "div";
  tagNew: "div";
  _new: "div";
  tagSale: "div";
  color: "div";
  color2: "div";
  rating: "div";
  price: "div";
  _3500: "div";
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicProduktKarte__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> =
  // Explicitly specify variants, args, and overrides as objects
  {
    variants?: PlasmicProduktKarte__VariantsArgs;
    args?: PlasmicProduktKarte__ArgsType;
    overrides?: NodeOverridesType<T>;
  } & Omit<PlasmicProduktKarte__VariantsArgs, ReservedPropsType> & // Specify variants directly as props
    /* Specify args directly as props*/ Omit<
      PlasmicProduktKarte__ArgsType,
      ReservedPropsType
    > &
    /* Specify overrides for each element directly as props*/ Omit<
      NodeOverridesType<T>,
      ReservedPropsType | VariantPropType | ArgPropType
    > &
    /* Specify props for the root element*/ Omit<
      Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
      ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
    >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicProduktKarte__ArgProps,
          internalVariantPropNames: PlasmicProduktKarte__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicProduktKarte__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicProduktKarte";
  } else {
    func.displayName = `PlasmicProduktKarte.${nodeName}`;
  }
  return func;
}

export const PlasmicProduktKarte = Object.assign(
  // Top-level PlasmicProduktKarte renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    img: makeNodeComponent("img"),
    overlay: makeNodeComponent("overlay"),
    icon5: makeNodeComponent("icon5"),
    addToCart: makeNodeComponent("addToCart"),
    icon6: makeNodeComponent("icon6"),
    icon7: makeNodeComponent("icon7"),
    heart2: makeNodeComponent("heart2"),
    icon4: makeNodeComponent("icon4"),
    eye: makeNodeComponent("eye"),
    freeBox: makeNodeComponent("freeBox"),
    tag: makeNodeComponent("tag"),
    tagNew: makeNodeComponent("tagNew"),
    _new: makeNodeComponent("_new"),
    tagSale: makeNodeComponent("tagSale"),
    color: makeNodeComponent("color"),
    color2: makeNodeComponent("color2"),
    rating: makeNodeComponent("rating"),
    price: makeNodeComponent("price"),
    _3500: makeNodeComponent("_3500"),

    // Metadata about props expected for PlasmicProduktKarte
    internalVariantProps: PlasmicProduktKarte__VariantProps,
    internalArgProps: PlasmicProduktKarte__ArgProps
  }
);

export default PlasmicProduktKarte;
/* prettier-ignore-end */
